---
title: "3 Model Selection and Validation"
author: "Paul Hively"
date: "May 16, 2016"
output: html_document
---

Source can be viewed [on GitHub](https://github.com/phively/gsb-sols-proj/blob/master/3%20Model%20selection%20and%20validation.Rmd)

# Setup and loading the data

Begin by loading the data used for the visualizations in part 1.

```{r, message=F, warning=F, cache=F}
#### Run Rscript0 to load useful packages and functions ----
source("Rscript0 - libraries.R")
source("f.Wrangle.R")
source("f.Diagnostics.R")
source("f.JMod.R")
```
```{r, message=F, warning=F, cache=F}
#### Model data cleanup ----
source("Rscript1a - modeling data appends.R")
source("Rscript1b - derived variables.R")
```

* [Rscript0 - libraries.R](https://github.com/phively/gsb-sols-proj/blob/master/Rscript0%20-%20libraries.R)
* [f.Wrangle.R](https://github.com/phively/gsb-sols-proj/blob/master/f.Wrangle.R)
* [f.Diagnostics.R](https://github.com/phively/gsb-sols-proj/blob/master/f.Diagnostics.R)
* [f.JMod.R](https://github.com/phively/gsb-sols-proj/blob/master/f.JMod.R)
* [Rscript1a - modeling data appends.R](https://github.com/phively/gsb-sols-proj/blob/master/Rscript1a%20-%20modeling%20data%20appends.R)
* [Rscript1b - derived variables.R](https://github.com/phively/gsb-sols-proj/blob/master/Rscript1b%20-%20derived%20variables.R)

The data frame `mderived` now contains the fields that may be useful for modeling.

# Quick review

My goal is to find a way to accurately forecast fundraising revenue. The current model -- "JMod" -- discounts solicitations to a fixed percentage of their expected value based on their current stage and how long it is until the end of the fiscal year.

| Stage    | July-Feb| Mar-Apr |   May   |  June   |
|----------|:-------:|:-------:|:-------:|:-------:| 
| Plan     |  1/6    | 1/8     | 0       |   0     |
| Clear    |  1/3    | 1/6     | 1/8     |   0     |
| Ask      |  2/3    | 1/3     | 1/6     |   1/8   |
| Oral     |  2/3    | 1/3     | 1/6     |   1/8   |
| Paperwork|  1      | 1       | 1       |   1     |

This makes use of three pieces of information: the current solicitation stage $S_{i}$, and today's date $t_{i}$ compared to the expected close date. 

[Last time](http://phively.github.io/gsb-sols-proj/2_Training_and_variable_selection.html), I ran the data through random forests and found several additional predictive variables: `Solicitation.Type.Desc`, `Planned.Amt`, `Expected.Amt`, and `Ask.Amt`.

```{r, echo=F, message=F, warning=F, cache=F}
# Load the saved errors file from last time
errors <- data.frame(read.csv("classification.errors.txt", sep="\t", stringsAsFactors=F))
# Keep only the relevant rows
errors <- errors[errors$Model %in% c("GLM", "JMod", "Random forest 3"),]
rownames(errors) <- NULL
```

# Logistic regression, take two

## Main effects model, raw data

What happens throwing all the main effects in without a transformation?

```{r, message=F, warning=F, cache=F}
# Plan model, main effects only
glm.pln <- glm(FY.Plan.Book ~ Solicitation.Type.Desc + Planned.Amt + Expected.Amt + Plan.Future + planning.fiscal.mo, data=mderived, family=binomial())
# Clear model, main effects only
glm.clr <- glm(FY.Clear.Book ~ Solicitation.Type.Desc + Planned.Amt + Expected.Amt + Clear.Future + clear.fiscal.mo, data=mderived, family=binomial())
# Ask model, main effects only
glm.ask <- glm(FY.Ask.Book ~ Solicitation.Type.Desc + Planned.Amt + Expected.Amt + Ask.Amt + Ask.Future + ask.fiscal.mo, data=mderived, family=binomial())
# Oral model, main effects only
glm.ora <- glm(FY.Oral.Book ~ Solicitation.Type.Desc + Planned.Amt + Expected.Amt + Ask.Amt + Oral.Future + oral.fiscal.mo, data=mderived, family=binomial())
# Put together the error rates
modnames <- c("Plan", "Clear", "Ask", "Oral")
confuse <- ConfusionMatrix(list(glm.pln, glm.clr, glm.ask, glm.ora), modnames=modnames, counts=F)
# Row to add to the error table
dat1 <- CalcErrorRates(confuse, model.name="GLM main effects notrans", modnames)
# Print the error table
kable(rbind(errors, dat1), digits=2)
```

That's a shockingly large improvement whether we use the original GLM or JMod as the baseline. It's not directly comparable to the out-of-bag Random forest 3 estimates, but I'll use a cross-validated error estimate after I'm happy with the final model form.

# Variable distributions

## Dollar amounts

Before looking at the data, I know that `Planned.Amt`, `Expected.Amt`, and `Ask.Amt` are continuous variables theoretically bounded by $[0,\infty)$, but expect them to be very unevenly distributed -- because of solicitation strategy they will tend to cluster around nice, round numbers like $100, $25,000, and so on. I don't want to use complex transformations (mixture basis, spline basis) to maintain interpretability, and because the lower bound is exactly 0, some simple transformations won't make sense.

Here's how the raw data look:

```{r, echo=F, message=F, warning=F, cache=F}
## Planned Ask Amount
ggplot(mderived[!is.na(mderived$Planned.Amt),], aes(x=Planned.Amt, y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_continuous(labels=scales::dollar) + labs(title="Planned Ask Amount")
## Expected Amount
ggplot(mderived[!is.na(mderived$Expected.Amt),], aes(x=Expected.Amt, y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_continuous(labels=scales::dollar) + labs(title="Expected Amount")
## Ask Amount
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=Ask.Amt, y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_continuous(labels=scales::dollar) + labs(title="Ask Amount")
```

There's a very small number of very large ask amounts. It's a little hard to see, so here's what the data look like on a $\log_{10}$ scale. So that we don't have to drop the 0s, define the transformation:

$$ x^\text{*} = \log_{10}(x + \alpha)$$

The smallest non-zero ask amount is:

```{r, message=F, warning=F, cache=F}
(alpha <- min(na.omit(mderived$Ask.Amt[mderived$Ask.Amt != 0])))
```

Plotting the data under this transformation.

```{r, echo=F, message=F, warning=F, cache=F}
## Planned Ask Amount
ggplot(mderived, aes(x=(Planned.Amt + alpha), y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_log10(breaks=10^(0:7), labels=scales::dollar) + labs(title="Planned Ask Amount", x=expression(paste(log[10],"(Planned.Amt + ",alpha,")")))
## Expected Amount
ggplot(mderived[!is.na(mderived$Expected.Amt),], aes(x=(Expected.Amt + alpha), y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_log10(breaks=10^(0:7), labels=scales::dollar) + labs(title="Expected Amount", x=expression(paste(log[10],"(Expected.Amt + ",alpha,")")))
## Ask Amount
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=(Ask.Amt + alpha), y=..density..)) + geom_histogram(bins=60, alpha=.5) + geom_density(color="gray") + scale_x_log10(breaks=10^(0:7), labels=scales::dollar) + labs(title="Ask Amount", x=expression(paste(log[10],"(Ask.Amt + ",alpha,")")))
```

That's actually not too far from symmetric.

## Interactions

Are there interactions worth looking at between `Solicitation.Type.Desc` and the others?

```{r, message=F, warning=F, cache=F}
table(mderived$Solicitation.Type.Desc)
```

Okay, `Solicitation.Type.Desc` clearly needs to be aggregated, so let's go with Other, Outright Gift, and Standard Pledge. By default, the alphabetically first factor level is the baseline under the treatment constraint, so the model will show contrasts between Other and Outright Gift, and Other and Standard Pledge, which is nice for interpretability.

Look at `Ask.Amt` by `Sol.Type.Agg`:

```{r, echo=F, message=F, warning=F, cache=F}
## Ask Amount
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=(Ask.Amt + alpha), y=..density..)) + geom_histogram(bins=60, alpha=.55) + geom_density(color="gray") + scale_x_log10(breaks=10^(0:7), labels=scales::dollar) + labs(title="Ask Amount", x=expression(paste(log[10],"(Ask.Amt + ",alpha,")"))) + facet_grid(Sol.Type.Agg ~ .)
## Ask Amount with result
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=(Ask.Amt + alpha), y=..density.., fill=FY.Ask.Book)) + geom_histogram(bins=60, alpha=.25, position="identity") + geom_density(alpha=.25) + scale_x_log10(breaks=10^(0:7), labels=scales::dollar) + labs(title="Ask Amount with result", x=expression(paste(log[10],"(Ask.Amt + ",alpha,")"))) + facet_grid(Sol.Type.Agg ~ .)
```

Other and Standard Pledge look more nearly flat than Outright Gift, so it could be worth checking out.

Also check `ask.fiscal.mo` by `Sol.Type.Agg`:

```{r, echo=F, message=F, warning=F, cache=F}
fiscal.month.name <- strtrim(month.name, 3)[c(7:12, 1:6)]
## Ask by month
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=ask.fiscal.mo, y=..density..)) + geom_histogram(bins=12, alpha=.5) + geom_density(color="gray") + labs(title="Asks by gift type") + facet_grid(Sol.Type.Agg ~ .) + scale_x_continuous(labels=fiscal.month.name, breaks=c(1:12))
## Ask by month with result
ggplot(mderived[!is.na(mderived$Ask.Amt),], aes(x=ask.fiscal.mo, y=..density.., fill=FY.Ask.Book)) + geom_histogram(bins=12, alpha=.25, position="identity") + geom_density(alpha=.25) + labs(title="Asks by gift type with result") + facet_grid(Sol.Type.Agg ~ .) + scale_x_continuous(labels=fiscal.month.name, breaks=c(1:12))
```

Outright gift asks have more success by far in December. Could be worth checking out.

Based on previous findings I expect the Annual Fund group is mostly responsible for plummeting closed solicitation rates toward the end of the fiscal year. Let's check.

```{r, echo=F, message=F, warning=F, cache=F}
## Ask by month with result
ggplot(mderived[!is.na(mderived$Ask.Amt) & !is.na(mderived$Ask.Band),], aes(x=ask.fiscal.mo, y=..density.., fill=FY.Ask.Book)) + geom_histogram(bins=12, alpha=.25, position="identity") + geom_density(alpha=.25) + labs(title="Asks by gift type") + facet_grid(Sol.Type.Agg ~ Ask.Band) + scale_x_continuous(labels=fiscal.month.name, breaks=c(1:12))
```

Confirmed -- the AF group gives on their schedule, not ours.

# Main effects model with transformed data

* Model error
* Model summary
* What's the reference level?

# Cross-validated error estimate

It's important that the coefficients be calculated separately for each fold

# Packages used
```{r}
session_info()
```